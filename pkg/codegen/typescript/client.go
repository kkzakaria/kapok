package typescript

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/kapok/kapok/pkg/codegen"
)

// ClientGenerator generates the SDK client and project structure
type ClientGenerator struct {
	typeMapper    *TypeMapper
	crudGenerator *CRUDGenerator
}

// NewClientGenerator creates a new client generator
func NewClientGenerator() *ClientGenerator {
	return &ClientGenerator{
		typeMapper:    NewTypeMapper(),
		crudGenerator: NewCRUDGenerator(),
	}
}

// PackageJSON represents the package.json structure
type PackageJSON struct {
	Name            string            `json:"name"`
	Version         string            `json:"version"`
	Description     string            `json:"description"`
	Main            string            `json:"main"`
	Types           string            `json:"types"`
	Scripts         map[string]string `json:"scripts"`
	Dependencies    map[string]string `json:"dependencies,omitempty"`
	DevDependencies map[string]string `json:"devDependencies"`
	Keywords        []string          `json:"keywords"`
	Author          string            `json:"author"`
	License         string            `json:"license"`
}

// TSConfig represents the tsconfig.json structure
type TSConfig struct {
	CompilerOptions map[string]interface{} `json:"compilerOptions"`
	Include         []string               `json:"include"`
	Exclude         []string               `json:"exclude"`
}

// GenerateClient generates the main KapokClient class
func (g *ClientGenerator) GenerateClient(schema *codegen.Schema) string {
	var sb strings.Builder

	sb.WriteString("import {\n")
	
	// Import all types
	for _, table := range schema.Tables {
		typeName := g.typeMapper.ToTypeName(table.Name)
		sb.WriteString(fmt.Sprintf("  %s,\n", typeName))
		sb.WriteString(fmt.Sprintf("  Create%sInput,\n", typeName))
		sb.WriteString(fmt.Sprintf("  Update%sInput,\n", typeName))
	}
	sb.WriteString("} from './types';\n\n")

	// Import all CRUD functions
	sb.WriteString("import {\n")
	for _, table := range schema.Tables {
		typeName := g.typeMapper.ToTypeName(table.Name)
		sb.WriteString(fmt.Sprintf("  create%s,\n", typeName))
		sb.WriteString(fmt.Sprintf("  get%sById,\n", typeName))
		sb.WriteString(fmt.Sprintf("  list%s,\n", typeName))
		sb.WriteString(fmt.Sprintf("  update%s,\n", typeName))
		sb.WriteString(fmt.Sprintf("  delete%s,\n", typeName))
	}
	sb.WriteString("} from './api';\n\n")

	// Generate main client class
	sb.WriteString("export class KapokClient {\n")
	sb.WriteString("  constructor(private baseUrl: string) {}\n\n")

	// Generate method groups for each table
	for _, table := range schema.Tables {
		typeName := g.typeMapper.ToTypeName(table.Name)
		fieldName := g.typeMapper.ToFieldName(table.Name)

		sb.WriteString(fmt.Sprintf("  %s = {\n", fieldName))
		sb.WriteString(fmt.Sprintf("    create: (input: Create%sInput) => create%s(this.baseUrl, input),\n", 
			typeName, typeName))
		
		// Get primary key type for getById and other methods
		// Determine primary key type for method signatures
		crudGen := NewCRUDGenerator()
		pkType := crudGen.getPrimaryKeyTSType(table)
		
		sb.WriteString(fmt.Sprintf("    getById: (id: %s) => get%sById(this.baseUrl, id),\n", 
			pkType, typeName))
		sb.WriteString(fmt.Sprintf("    list: (options?: { limit?: number; offset?: number }) => list%s(this.baseUrl, options),\n", 
			typeName))
		sb.WriteString(fmt.Sprintf("    update: (id: %s, input: Update%sInput) => update%s(this.baseUrl, id, input),\n", 
			pkType, typeName, typeName))
		sb.WriteString(fmt.Sprintf("    delete: (id: %s) => delete%s(this.baseUrl, id),\n", 
			pkType, typeName))
		sb.WriteString("  };\n\n")
	}

	sb.WriteString("}\n")

	return sb.String()
}

// GenerateIndexFile generates the main index.ts barrel export
func (g *ClientGenerator) GenerateIndexFile(schema *codegen.Schema) string {
	var sb strings.Builder

	sb.WriteString("// Auto-generated by Kapok SDK Generator\n")
	sb.WriteString("// Do not edit manually\n\n")

	sb.WriteString("export * from './types';\n")
	sb.WriteString("export * from './api';\n")
	sb.WriteString("export { KapokClient } from './client';\n")

	return sb.String()
}

// GenerateTypesIndexFile generates the types/index.ts file
func (g *ClientGenerator) GenerateTypesIndexFile(schema *codegen.Schema) string {
	var sb strings.Builder

	sb.WriteString("// Auto-generated types\n\n")

	for _, table := range schema.Tables {
		sb.WriteString(g.typeMapper.GenerateInterface(table))
		sb.WriteString("\n")
		sb.WriteString(g.typeMapper.GenerateCreateInput(table))
		sb.WriteString("\n")
		sb.WriteString(g.typeMapper.GenerateUpdateInput(table))
		sb.WriteString("\n")
	}

	return sb.String()
}

// GenerateAPIIndexFile generates the api/index.ts file with all CRUD functions
func (g *ClientGenerator) GenerateAPIIndexFile(schema *codegen.Schema) string {
	var sb strings.Builder

	sb.WriteString("// Auto-generated API functions\n\n")
	
	// Import types
	sb.WriteString("import {\n")
	for _, table := range schema.Tables {
		typeName := g.typeMapper.ToTypeName(table.Name)
		sb.WriteString(fmt.Sprintf("  %s,\n", typeName))
		sb.WriteString(fmt.Sprintf("  Create%sInput,\n", typeName))
		sb.WriteString(fmt.Sprintf("  Update%sInput,\n", typeName))
	}
	sb.WriteString("} from '../types';\n\n")

	// Generate all CRUD functions
	for i, table := range schema.Tables {
		sb.WriteString(g.crudGenerator.GenerateAllCRUD(table))
		if i < len(schema.Tables)-1 {
			sb.WriteString("\n")
		}
	}

	return sb.String()
}

// GeneratePackageJSON generates the package.json file
func (g *ClientGenerator) GeneratePackageJSON(projectName string) (string, error) {
	pkg := PackageJSON{
		Name:        projectName,
		Version:     "0.1.0",
		Description: "Auto-generated TypeScript SDK for Kapok backend",
		Main:        "dist/index.js",
		Types:       "dist/index.d.ts",
		Scripts: map[string]string{
			"build":      "tsc",
			"watch":      "tsc --watch",
			"prepublish": "npm run build",
		},
		DevDependencies: map[string]string{
			"typescript": "^5.0.0",
			"@types/node": "^20.0.0",
		},
		Keywords: []string{"kapok", "sdk", "api", "typescript"},
		Author:   "",
		License:  "MIT",
	}

	bytes, err := json.MarshalIndent(pkg, "", "  ")
	if err != nil {
		return "", err
	}

	return string(bytes), nil
}

// GenerateTSConfig generates the tsconfig.json file
func (g *ClientGenerator) GenerateTSConfig() (string, error) {
	config := TSConfig{
		CompilerOptions: map[string]interface{}{
			"target":                  "ES2020",
			"module":                  "commonjs",
			"lib":                     []string{"ES2020"},
			"declaration":             true,
			"outDir":                  "./dist",
			"rootDir":                 "./src",
			"strict":                  true,
			"esModuleInterop":         true,
			"skipLibCheck":            true,
			"forceConsistentCasingInFileNames": true,
		},
		Include: []string{"src/**/*"},
		Exclude: []string{"node_modules", "dist"},
	}

	bytes, err := json.MarshalIndent(config, "", "  ")
	if err != nil {
		return "", err
	}

	return string(bytes), nil
}

// WriteSDK writes the complete SDK to the output directory
func (g *ClientGenerator) WriteSDK(outputDir string, schema *codegen.Schema, projectName string) error {
	// Create directory structure
	srcDir := filepath.Join(outputDir, "src")
	typesDir := filepath.Join(srcDir, "types")
	apiDir := filepath.Join(srcDir, "api")

	for _, dir := range []string{srcDir, typesDir, apiDir} {
		if err := os.MkdirAll(dir, 0755); err != nil {
			return fmt.Errorf("failed to create directory %s: %w", dir, err)
		}
	}

	// Generate and write files
	files := map[string]string{
		filepath.Join(srcDir, "index.ts"):       g.GenerateIndexFile(schema),
		filepath.Join(srcDir, "client.ts"):      g.GenerateClient(schema),
		filepath.Join(typesDir, "index.ts"):     g.GenerateTypesIndexFile(schema),
		filepath.Join(apiDir, "index.ts"):       g.GenerateAPIIndexFile(schema),
	}

	// Add package.json
	packageJSON, err := g.GeneratePackageJSON(projectName)
	if err != nil {
		return fmt.Errorf("failed to generate package.json: %w", err)
	}
	files[filepath.Join(outputDir, "package.json")] = packageJSON

	// Add tsconfig.json
	tsConfig, err := g.GenerateTSConfig()
	if err != nil {
		return fmt.Errorf("failed to generate tsconfig.json: %w", err)
	}
	files[filepath.Join(outputDir, "tsconfig.json")] = tsConfig

	// Add README.md
	readme := g.generateReadme(projectName)
	files[filepath.Join(outputDir, "README.md")] = readme

	// Write all files
	for path, content := range files {
		if err := os.WriteFile(path, []byte(content), 0644); err != nil {
			return fmt.Errorf("failed to write file %s: %w", path, err)
		}
	}

	return nil
}

// generateReadme creates a basic README for the SDK
func (g *ClientGenerator) generateReadme(projectName string) string {
	var sb strings.Builder
	
	sb.WriteString("# ")
	sb.WriteString(projectName)
	sb.WriteString("\n\n")
	sb.WriteString("Auto-generated TypeScript SDK for your Kapok backend.\n\n")
	sb.WriteString("## Installation\n\n")
	sb.WriteString("```bash\n")
	sb.WriteString("npm install\n")
	sb.WriteString("npm run build\n")
	sb.WriteString("```\n\n")
	sb.WriteString("## Usage\n\n")
	sb.WriteString("```typescript\n")
	sb.WriteString("import { KapokClient } from './")
	sb.WriteString(projectName)
	sb.WriteString("';\n\n")
	sb.WriteString("const client = new KapokClient('http://localhost:8080/api');\n\n")
	sb.WriteString("// Use the SDK\n")
	sb.WriteString("const user = await client.users.create({\n")
	sb.WriteString("  email: 'user@example.com',\n")
	sb.WriteString("  name: 'John Doe',\n")
	sb.WriteString("});\n\n")
	sb.WriteString("const users = await client.users.list({ limit: 10 });\n")
	sb.WriteString("```\n\n")
	sb.WriteString("## Development\n\n")
	sb.WriteString("```bash\n")
	sb.WriteString("npm run watch  # Watch for changes\n")
	sb.WriteString("npm run build  # Build TypeScript\n")
	sb.WriteString("```\n\n")
	sb.WriteString("---\n\n")
	sb.WriteString("Generated by [Kapok](https://github.com/kapok/kapok)\n")
	
	return sb.String()
}

