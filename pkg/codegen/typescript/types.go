package typescript

import (
	"fmt"
	"strings"

	"github.com/iancoleman/strcase"
	"github.com/kapok/kapok/pkg/codegen"
)

// TypeMapper maps PostgreSQL types to TypeScript types
type TypeMapper struct{}

// NewTypeMapper creates a new type mapper
func NewTypeMapper() *TypeMapper {
	return &TypeMapper{}
}

// MapType converts PostgreSQL type to TypeScript type
func (tm *TypeMapper) MapType(pgType string, isNullable bool) string {
	tsType := tm.mapBaseType(pgType)
	
	if isNullable {
		return tsType + " | null"
	}
	
	return tsType
}

// mapBaseType converts PostgreSQL base type to TypeScript
func (tm *TypeMapper) mapBaseType(pgType string) string {
	// Normalize type (remove precision/scale)
	pgType = strings.ToLower(pgType)
	
	switch {
	// String types
	case strings.Contains(pgType, "char"), strings.Contains(pgType, "text"):
		return "string"
	
	// Numeric types
	case strings.Contains(pgType, "int"), 
	     strings.Contains(pgType, "serial"),
	     pgType == "smallint",
	     pgType == "bigint":
		return "number"
	
	case strings.Contains(pgType, "numeric"),
	     strings.Contains(pgType, "decimal"),
	     strings.Contains(pgType, "real"),
	     strings.Contains(pgType, "double"),
	     pgType == "money":
		return "number"
	
	// Boolean
	case pgType == "boolean", pgType == "bool":
		return "boolean"
	
	// Date/Time types
	case strings.Contains(pgType, "timestamp"),
	     strings.Contains(pgType, "date"),
	     strings.Contains(pgType, "time"):
		return "Date"
	
	// JSON types
	case pgType == "json", pgType == "jsonb":
		return "Record<string, any>"
	
	// UUID
	case pgType == "uuid":
		return "string"
	
	// Array types
	case strings.HasPrefix(pgType, "ARRAY"):
		return "any[]"
	
	// Default
	default:
		return "any"
	}
}

// ToTypeName converts table name to TypeScript type name
func (tm *TypeMapper) ToTypeName(tableName string) string {
	// Convert snake_case to PascalCase
	return strcase.ToCamel(tableName)
}

// ToFieldName converts column name to TypeScript field name
func (tm *TypeMapper) ToFieldName(columnName string) string {
	// Convert snake_case to camelCase
	return strcase.ToLowerCamel(columnName)
}

// GenerateInterface generates TypeScript interface for a table
func (tm *TypeMapper) GenerateInterface(table *codegen.Table) string {
	var sb strings.Builder
	
	typeName := tm.ToTypeName(table.Name)
	
	// Write interface declaration
	sb.WriteString(fmt.Sprintf("export interface %s {\n", typeName))
	
	// Write fields
	for _, col := range table.Columns {
		fieldName := tm.ToFieldName(col.Name)
		tsType := tm.MapType(col.DataType, col.IsNullable)
		
		sb.WriteString(fmt.Sprintf("  %s: %s;\n", fieldName, tsType))
	}
	
	sb.WriteString("}\n")
	
	return sb.String()
}

// GenerateCreateInput generates Create input type (excludes auto-generated fields)
func (tm *TypeMapper) GenerateCreateInput(table *codegen.Table) string {
	var sb strings.Builder
	
	typeName := tm.ToTypeName(table.Name)
	
	sb.WriteString(fmt.Sprintf("export interface Create%sInput {\n", typeName))
	
	// Exclude auto-generated columns (id, created_at, updated_at)
	for _, col := range table.Columns {
		// Skip auto-generated columns
		if tm.isAutoGenerated(col) {
			continue
		}
		
		fieldName := tm.ToFieldName(col.Name)
		tsType := tm.MapType(col.DataType, col.IsNullable)
		
		// Make optional if has default or nullable
		optional := ""
		if col.IsNullable || col.DefaultValue != nil {
			optional = "?"
		}
		
		sb.WriteString(fmt.Sprintf("  %s%s: %s;\n", fieldName, optional, tsType))
	}
	
	sb.WriteString("}\n")
	
	return sb.String()
}

// GenerateUpdateInput generates Update input type (all fields optional)
func (tm *TypeMapper) GenerateUpdateInput(table *codegen.Table) string {
	var sb strings.Builder
	
	typeName := tm.ToTypeName(table.Name)
	
	sb.WriteString(fmt.Sprintf("export interface Update%sInput {\n", typeName))
	
	// All fields optional for update (except PK)
	for _, col := range table.Columns {
		// Skip primary key
		if table.PrimaryKey != nil && contains(table.PrimaryKey.ColumnNames, col.Name) {
			continue
		}
		
		// Skip auto-generated timestamp columns
		if col.Name == "created_at" || col.Name == "updated_at" {
			continue
		}
		
		fieldName := tm.ToFieldName(col.Name)
		tsType := tm.MapType(col.DataType, col.IsNullable)
		
		sb.WriteString(fmt.Sprintf("  %s?: %s;\n", fieldName, tsType))
	}
	
	sb.WriteString("}\n")
	
	return sb.String()
}

// isAutoGenerated checks if column is auto-generated
func (tm *TypeMapper) isAutoGenerated(col *codegen.Column) bool {
	// Check for serial types
	if strings.Contains(strings.ToLower(col.DataType), "serial") {
		return true
	}
	
	// Check for common auto-generated columns with defaults
	if col.DefaultValue != nil {
		defaultVal := strings.ToLower(*col.DefaultValue)
		
		// nextval indicates sequence (serial)
		if strings.Contains(defaultVal, "nextval") {
			return true
		}
		
		// CURRENT_TIMESTAMP indicates auto-timestamp
		if strings.Contains(defaultVal, "current_timestamp") ||
		   strings.Contains(defaultVal, "now()") {
			return true
		}
	}
	
	return false
}

// contains checks if slice contains string
func contains(slice []string, item string) bool {
	for _, s := range slice {
		if s == item {
			return true
		}
	}
	return false
}
